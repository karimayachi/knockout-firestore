{"version":3,"sources":["webpack://kofs/webpack/universalModuleDefinition","webpack://kofs/webpack/bootstrap","webpack://kofs/external {\"commonjs\":\"knockout\",\"commonjs2\":\"knockout\",\"amd\":\"knockout\",\"root\":\"ko\"}","webpack://kofs/./src/mergeObjects.ts","webpack://kofs/./src/Logger.ts","webpack://kofs/./src/Bindable.ts","webpack://kofs/./src/BindableArray.ts","webpack://kofs/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","mergeObjects","target","source","newTarget","addPrototypeToEndOfChain","chain","pTarget","getPrototypeOf","Function","setPrototypeOf","_i","_a","getOwnPropertyNames","length","descriptor","getOwnPropertyDescriptor","writable","configurable","set","Logger","logLevel","_this","this","debug","args","arguments","unshift","console","apply","error","Bindable_ModelExtensions","ModelExtensions","logger","lock","twoWayBinding","state","external_commonjs_knockout_commonjs2_knockout_amd_knockout_root_ko_","modified","getFlatDocument","document","keys","includes","propertyValue","save","undefined","fsBaseCollection","thisDocument","add","then","doc","id","fsDocumentId","catch","update","delete","saveProperty","Array","isArray","filter","createBindable","model","bindableModel","assign","elementName","subscribe","BindableArray_ArrayExtensions","ArrayExtensions","localOnly","getDocument","contents_1","bindableDoc","detach","item","remove","destroy","saveAll","contents_2","bindableItem","collectionChanged","changes","fsCollection","change","status","bindable_1","this_1","parent","include","collectionRef","collection","bindCollection","class","orderBy","_b","_c","childItem","bindableChild","createAndBindDeepIncludes","bindable_2","changes_1","getBoundCollection","options","observableArray","where","query","where_1","whereClause","orderBy_1","orderByClause","createFirestoreQuery","bindableArray","koObservableArray","extension","fsQuery","removeAll","createBindableArray","onSnapshot","snapshot","docChanges","forEach","metadata","hasPendingWrites","type","index","newIndex","ref","explodeObject","splice","localDoc","firestoreDocument","localObject","deepInclude","propertyData","toDate","__webpack_exports__"],"mappings":"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","file":"knockout.firestore.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"knockout\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"knockout\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"kofs\"] = factory(require(\"knockout\"));\n\telse\n\t\troot[\"kofs\"] = factory(root[\"ko\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","export function mergeObjects<TTarget, TSource>(target: TTarget, source: TSource): TTarget & TSource {\n\n    let newTarget: TTarget & TSource = <TTarget & TSource>target;\n    let pSource: any = Object.getPrototypeOf(source);\n    \n    addPrototypeToEndOfChain(target, pSource);\n\n    /* copy the properties (not on the prototype chain, but including the non-enumerable) to the target */\n    for (let key of Object.getOwnPropertyNames(source)) {\n        let descriptor: PropertyDescriptor | undefined = Object.getOwnPropertyDescriptor(source, key);\n\n        if (descriptor && (!descriptor.writable || !descriptor.configurable || !descriptor.enumerable || descriptor.get || descriptor.set)) {\n            Object.defineProperty(target, key, descriptor);\n        }\n        else {\n            (<any>target)[key] = (<any>source)[key];\n        }\n    }\n\n    return newTarget;\n}\n\nfunction addPrototypeToEndOfChain(chain: any, prototype: any) {\n    let pTarget: any = Object.getPrototypeOf(chain);\n\n    if(pTarget === prototype) {  /* prototype already added to this chain */\n    }\n    else if(pTarget === Object.prototype || pTarget === Function.prototype) { /* end of chain: add prototype */\n        Object.setPrototypeOf(chain, prototype);\n    }\n    else { /* recursive go down chain */\n        addPrototypeToEndOfChain(pTarget, prototype);\n    }\n}","export class Logger {\n    logLevel: number;\n\n    constructor(logLevel?: number) {\n        this.logLevel = logLevel || 0;\n    }\n\n    debug = (...args: any[]): void => {\n        if(this.logLevel == 2) {\n            args.unshift('[KOFS]');\n            console.debug(...args);\n        }\n    }\n    \n    error = (...args: any[]): void => {\n        if(this.logLevel > 0) {\n            args.unshift('[KOFS]');\n            console.error(...args);\n        }\n    }\n}","import * as ko from 'knockout';\nimport { Observable, PureComputed } from 'knockout';\nimport { firestore } from 'firebase';\nimport { mergeObjects } from './mergeObjects';\nimport { Logger } from './Logger';\n\nexport type Bindable<T> = ModelExtensions & T;\n\nexport class ModelExtensions {\n    fsDocumentId?: string;\n    fsBaseCollection?: firestore.CollectionReference;\n    includes?: { property: { class: new () => any, orderBy: string[] | string[][] } };\n    lock: boolean;\n    twoWayBinding: boolean;\n    state: Observable<number>;\n    modified: PureComputed<boolean>; /* Why is this hidden again? */\n    logger: Logger;\n\n    constructor(logger?: Logger) {\n        this.lock = false;\n        this.twoWayBinding = true;\n\n        this.state = ko.observable(0); /* UNCHANGED */\n        this.modified = ko.pureComputed((): boolean => {\n            return this.state() != 0;\n        });\n\n        this.logger = logger || new Logger();\n\n        /* Don't use decorators or end up in Prototype Hell */\n        Object.defineProperty(this, 'state', {\n            enumerable: false,\n            configurable: false,\n            writable: false\n        });\n\n        Object.defineProperty(this, 'modified', {\n            enumerable: false,\n            configurable: false,\n            writable: false\n        });\n    }\n\n    getFlatDocument(): any {\n        let document: any = {};\n\n        /* enumerate using keys() and filter out protoype functions with hasOwnProperty() in stead of using \n         * getOwnPropertyNames(), because the latter also returns non-enumerables */\n        for (let key of Object.keys(this)) {\n            if (!this.hasOwnProperty(key)) continue;\n\n            let property: any = (<any>this)[key];\n\n            /* flatten properties, except computed and deep includes */\n            if (ko.isObservable(property) &&\n                !ko.isComputed(property) &&\n                !(<any>this.includes)[key]) {\n                let propertyValue: any;\n                if (typeof property() === 'boolean' || typeof property() === 'number') {\n                    propertyValue = property(); /* 0 or false should just be inserted as a value */\n                }\n                else {\n                    propertyValue = property() || ''; /* but not null, undefined or the likes */\n                }\n\n                document[key] = propertyValue;\n            }\n        }\n\n        return document;\n    }\n\n    save(): void {\n        if (this.state() == 0) {\n            this.logger.debug('Firestore document ' + this.fsDocumentId + ' unchanged');\n            return;\n        }\n\n        if (this.fsBaseCollection === undefined) {\n            this.logger.error('Firestore document ' + this.fsDocumentId + ' not part of a Collection');\n            return;\n        }\n\n        let thisDocument: any = this.getFlatDocument();\n\n        if (this.state() == 1) { /* NEW */\n            this.fsBaseCollection.add(thisDocument).then((doc: firestore.DocumentReference): void => {\n                this.logger.debug('Firestore document ' + doc.id + ' added to database');\n                this.fsDocumentId = doc.id;\n                if (this.state() == 2) { /* document was modified while saving */\n                    this.logger.debug('Firestore document ' + doc.id + ' was modified during insert, save changes');\n                    this.save();\n                }\n                else {\n                    this.state(0);\n                }\n            }).catch((error: any): void => {\n                this.logger.error('Error adding Firestore document :', error);\n            });\n        }\n        else if (this.state() == 2) { /* MODIFIED */\n            this.fsBaseCollection.doc(this.fsDocumentId).update(thisDocument).then((): void => {\n                this.logger.debug('Firestore document ' + this.fsDocumentId + ' saved to database');\n                this.state(0);\n            }).catch((error: any): void => {\n                this.logger.error('Error saving Firestore document :', error);\n            });\n        }\n        else if (this.state() == 3) { /* DELETED */\n            this.fsBaseCollection.doc(this.fsDocumentId).delete().then((): void => {\n                this.logger.debug('Firestore document ' + this.fsDocumentId + ' deleted from database');\n            }).catch((error: any): void => {\n                this.logger.error('Error saving Firestore document :', error);\n            });\n        }\n    }\n\n    saveProperty(property: string, value: any): void {\n        let doc: any = {};\n\n        if (typeof value == 'number' ||\n            typeof value == 'string' ||\n            typeof value == 'boolean') {\n            doc[property] = value;\n        }\n        else if (Array.isArray(value)) { /* only serialize non-complex elements.. TODO: serialize knockout observables */\n            doc[property] = value.filter((value: any) => {\n                return typeof value == 'number' ||\n                    typeof value == 'string' ||\n                    typeof value == 'boolean';\n            });\n        }\n\n        if (this.fsBaseCollection === undefined) {\n            this.logger.error('Firestore document ' + this.fsDocumentId + ' not part of a Collection');\n            return;\n        }\n\n        /* it can happen that a property change triggers saveProperty,\n         * while the document is not yet properly saved in Firestore and\n         * has no fsDocumentId yet. In that case don't save to Firestore,\n         * but record the change and mark this document MODIFIED */\n        if (typeof this.fsDocumentId === 'undefined') {\n            this.state(2); // MODIFIED\n        }\n        else {\n            this.fsBaseCollection.doc(this.fsDocumentId).update(doc).then((): void => {\n                this.logger.debug('Firestore document ' + this.fsDocumentId + ' saved to database');\n            }).catch((error: any): void => {\n                this.logger.error('Error saving Firestore document :', error);\n            });\n        }\n    }\n}\n\n/**\n * Creates a bindable from the given object and optionally the deep includes\n * (navigation properties)\n * @param model the object to be made bindable\n * @param includes (optional) the deep includes for eager loading\n */\nexport function createBindable<T>(model: T, includes?: any, logger?: Logger): Bindable<T> {\n\n    let extension = new ModelExtensions(logger);\n\n    let bindableModel: Bindable<T> = mergeObjects(model, extension);\n\n    bindableModel.includes = Object.assign(includes || {}, bindableModel.includes);\n\n    /* subscribe to the Knockout changes\n     * enumerate using keys() and filter out protoype functions with hasOwnProperty() in stead of using \n     * getOwnPropertyNames(), because the latter also returns non-enumerables */\n    for (let key of Object.keys(bindableModel)) {\n        if (!bindableModel.hasOwnProperty(key)) continue;\n\n        let property: any = (<any>bindableModel)[key];\n\n        /* Bind listeners to the properties */\n        if (ko.isObservable(property) &&\n            (!ko.isObservableArray(property) || !(<any>bindableModel.includes)[key]) &&\n            !ko.isComputed(property)) {\n            ((elementName: string): void => {\n                property.subscribe((value: any): void => {\n                    bindableModel.logger.debug('Knockout observable property \"' + elementName + '\" changed. LocalOnly: ' + bindableModel.lock);\n\n                    /* ignore updates triggered by incoming changes from Firebase */\n                    if (!bindableModel.lock) {\n                        if (bindableModel.twoWayBinding) {\n                            bindableModel.saveProperty(elementName, value);\n                        }\n                        else if (bindableModel.state() != 1) { /* if state is NEW keep it in this state untill it is saved, even if it's modified in the mean time */\n                            bindableModel.state(2); /* MODIFIED */\n                        }\n                    }\n                });\n            })(key);\n        }\n    }\n\n    return bindableModel;\n}\n","import * as ko from 'knockout';\nimport { ObservableArray, utils } from 'knockout';\nimport { firestore } from 'firebase';\nimport { Bindable, createBindable, ModelExtensions } from './Bindable';\nimport { mergeObjects } from './mergeObjects';\nimport { bindCollection } from './index';\nimport { Logger } from './Logger';\n\nexport type BindableArray<T> = ObservableArray<T> & ArrayExtensions<T>;\n\nexport class ArrayExtensions<T> {\n    fsQuery?: firestore.Query;\n    fsCollection?: firestore.CollectionReference;\n    includes?: { [key: string]: { class: new () => any, orderBy: string[] | string[][] } };\n    localOnly: boolean;\n    twoWayBinding: boolean;\n    logger: Logger;\n\n    constructor(logger?: Logger) {\n        this.localOnly = false;\n        this.twoWayBinding = false;\n        this.logger = logger || new Logger();\n    }\n\n    getDocument(id: string): Bindable<T> | null {\n        /* assume 'this' is merged with an ObservableArray */\n        let contents: T[] = (<BindableArray<T>><any>this)();\n\n        for (let doc of contents) {\n            /* assume all documents are converted to Bindable */\n            let bindableDoc: Bindable<T> = <Bindable<T>>doc;\n\n            if (bindableDoc.fsDocumentId === id)\n                return bindableDoc;\n        }\n\n        return null;\n    }\n\n    detach(item: T): void {\n        /* assume 'this' is merged with an ObservableArray */\n        let observableArray: BindableArray<T> = (<BindableArray<T>><any>this);\n\n        /* if this collection is Two-Way bound, just delete */\n        if (observableArray.twoWayBinding) {\n            observableArray.remove(item);\n        }\n        else {\n            /* assume all items are converted to Bindable */\n            (<Bindable<T>>item).state(3); /* DELETED */\n\n            /* use Knockout's internal _destroy property to filter this item out of the UI */\n            observableArray.destroy(item);\n\n            this.logger.debug('Document \"' + (<Bindable<T>>item).fsDocumentId + '\" detached from local collection.');\n        }\n    }\n\n    saveAll(): void {\n        /* assume 'this' is merged with an ObservableArray */\n        let contents: T[] = (<BindableArray<T>><any>this)();\n\n        for (let item of contents) {\n            /* assume all items are converted to Bindable */\n            let bindableItem: Bindable<T> = <Bindable<T>>item\n\n            if (bindableItem.state() !== 0) {\n                bindableItem.save();\n            }\n        }\n    }\n}\n\nexport function createBindableArray<T>(koObservableArray: ObservableArray<T>, logger?: Logger): BindableArray<T> {\n\n    let extension: ArrayExtensions<T> = new ArrayExtensions(logger);\n    let bindableArray: BindableArray<T>;\n\n    if((<BindableArray<T>>koObservableArray).fsQuery) {\n        /* if already bound, don't rebind, but do clear, localOnly\n         * Assume bound when fsQuery property is found on the object */\n        bindableArray = <BindableArray<T>>koObservableArray;\n        bindableArray.localOnly = true;\n        bindableArray.removeAll();\n        bindableArray.localOnly = false;\n    }\n    else {\n        /* bind */\n        bindableArray = mergeObjects(koObservableArray, extension);\n        bindableArray.subscribe<BindableArray<T>>(collectionChanged, bindableArray, 'arrayChange');\n    }\n    \n    return bindableArray;\n}\n\nfunction collectionChanged<T>(this: ArrayExtensions<T>, changes: utils.ArrayChanges<T>) {\n    /* if local only change (e.g. triggered by load from Firestore) return */\n    /* also return if the collection is not set, which should'nt be able to happen, but to satisfy the type system, check for it */\n    if (this.localOnly || this.fsCollection === undefined) { return; }\n\n    for (let change of changes) {\n        let item: T = change.value;\n\n        switch (change.status) {\n            case 'added':\n                /* extend the Model with the ObservableDocument functionality\n                 * extend / overrule the includes with includes from passed options (only one level) */\n                let bindable: Bindable<T> = createBindable(item, this.includes, this.logger);\n                bindable.twoWayBinding = this.twoWayBinding;\n\n                if (this.twoWayBinding) {\n                    this.logger.debug('Adding new document to Firestore collection \"' + this.fsCollection.id + '\"');\n\n                    this.fsCollection.add(bindable.getFlatDocument())\n                        .then((doc: firestore.DocumentReference): void => {\n                            bindable.fsBaseCollection = doc.parent;\n                            bindable.fsDocumentId = doc.id;\n\n                            /* get deep includes for Array properties \n                             * TODO: fix that the deep linking is done here AND in explodeObject in knockout.firestore.js */\n                            createAndBindDeepIncludes(bindable);\n                        }).catch((error): void => {\n                            this.logger.error('Error saving Firestore document :', error);\n                        });\n                }\n                else {\n                    this.logger.debug('Adding new document to local collection only');\n                    bindable.state(1); /* NEW */\n                    bindable.fsBaseCollection = this.fsCollection;\n                }\n\n                break;\n            case 'deleted':\n                if (this.twoWayBinding) {\n                    this.logger.debug('Deleting document \"' + (<Bindable<T>>item).fsDocumentId + '\" from Firestore collection \"' + this.fsCollection.id + '\"');\n\n                    let bindable: Bindable<T> = <Bindable<T>>item;\n\n                    if (bindable.fsBaseCollection === undefined) { continue; } /* can't happen, but satisfy the type system by checking */\n\n                    bindable.fsBaseCollection.doc(bindable.fsDocumentId)\n                        .delete()\n                        .catch((error: any): void => {\n                            this.logger.error('Error deleting Firestore document :', error);\n                        });\n                }\n                else {\n                    this.logger.debug('Document \"' + (<Bindable<T>>item).fsDocumentId + '\" removed from local collection.');\n                    this.logger.debug('You\\'re not using Two-Way binding, please use .detach() in stead of .remove() to persist the change when syncing to Firestore');\n                }\n\n                break;\n        }\n    }\n}\n\nfunction createAndBindDeepIncludes<T>(item: Bindable<T>) {\n    /* enumerate using keys() and filter out protoype functions with hasOwnProperty() in stead of using \n     * getOwnPropertyNames(), because the latter also returns non-enumerables */\n    for (let key of Object.keys(item)) {\n\n        if (!item.hasOwnProperty(key) || item.fsBaseCollection === undefined) continue;\n\n        let property = (<any>item)[key];\n\n        /* get deep includes for Array properties */\n        if (ko.isObservableArray(property) && item.includes && (<any>item.includes)[key]) {\n            let include = (<any>item.includes)[key];\n            let collectionRef = item.fsBaseCollection\n                .doc(item.fsDocumentId)\n                .collection(key);\n\n            bindCollection(property, collectionRef, include.class, { twoWayBinding: item.twoWayBinding, orderBy: include.orderBy, logLevel: item.logger.logLevel }); // TODO: Pass logger in stead of logLevel\n\n            /* if the collection was locally already filled with data */\n            /* TODO: Transaction for speed */\n            for (let childItem of property()) {\n                let bindableChild: ModelExtensions = createBindable(childItem, {}, item.logger);\n                bindableChild.fsBaseCollection = collectionRef;\n                bindableChild.twoWayBinding = item.twoWayBinding;\n                bindableChild.state(1); /* NEW */\n                bindableChild.save();\n            }\n        }\n    }\n}","import { firestore } from 'firebase';\nimport * as ko from 'knockout';\nimport { ObservableArray } from 'knockout';\nimport { BindableArray, createBindableArray } from './BindableArray';\nimport { Bindable, createBindable } from './Bindable';\nimport { Logger } from './Logger';\n\nexport interface KofsOptions {\n    where: [string, string, any] | [string, string, any][];\n    orderBy: [string, string] | [string, string][];\n    includes: { [key: string]: { class: new () => any, orderBy: [string, string] | [string, string][] } };\n    twoWayBinding: boolean;\n    logLevel: number\n}\n\nexport { BindableArray, Bindable };\n\nexport function getBoundCollection<T>(fsCollection: firestore.CollectionReference, model: new () => T, options: Partial<KofsOptions>): BindableArray<T> {\n    /* create the collection as a ko.observableArray and bind it */\n    let observableArray: ObservableArray<T> = ko.observableArray();\n\n    bindCollection(observableArray, fsCollection, model, options);\n\n    return <BindableArray<T>>observableArray;\n}\n\nexport function bindCollection<T>(observableArray: ObservableArray<T>, fsCollection: firestore.CollectionReference, model: new () => T, options: Partial<KofsOptions>): void {\n    /* settings */\n    options = options || {};\n    let where = options.where || [];\n    let orderBy = options.orderBy || [];\n    let includes = options.includes || {};\n    let twoWayBinding: boolean = typeof options.twoWayBinding === 'undefined' ? true : options.twoWayBinding;\n\n    /* create the Firestore query from the collection and the options */\n    let query: firestore.Query = createFirestoreQuery(<firestore.Query>fsCollection, where, orderBy);\n\n    /* create logger */\n    const logger = new Logger(options.logLevel);\n\n    /* extend the observableArray with our functions */\n    let bindableArray: BindableArray<T> = createBindableArray(observableArray, logger);\n    bindableArray.twoWayBinding = twoWayBinding;\n    bindableArray.fsQuery = query;\n    bindableArray.fsCollection = fsCollection;\n    bindableArray.includes = includes;\n\n    /* subscribe to the Firestore collection */\n    query.onSnapshot((snapshot: firestore.QuerySnapshot): void => {\n        snapshot.docChanges().forEach((change: firestore.DocumentChange): void => {\n            /* ignore local changes */\n            if (!change.doc.metadata.hasPendingWrites) {\n\n                if (change.type === 'added') {\n                    logger.debug('Firestore object ' + change.doc.id + ' added to collection');\n                    let item: T & { includes?: any } = new model();\n                    let index: number = change.newIndex;\n\n                    /* extend the Model with the Bindable functionality */\n                    let combinedIncludes = Object.assign(includes, item.includes);\n                    let bindableItem: Bindable<T> = createBindable(item, combinedIncludes, logger);\n\n                    /* fill the new object with meta-data\n                     * extend / overrule the includes with includes from the passed options */\n                    bindableItem.fsBaseCollection = change.doc.ref.parent;\n                    bindableItem.fsDocumentId = change.doc.id;\n                    bindableItem.twoWayBinding = twoWayBinding;\n\n                    /* explode the data AND deep include if two-way */\n                    explodeObject(change.doc, bindableItem, twoWayBinding);\n\n                    /* set the collection to localOnly to ignore these incoming changes from Firebase */\n                    bindableArray.localOnly = true;\n                    bindableArray.splice(index, 0, bindableItem);\n                    bindableArray.localOnly = false;\n                }\n                if (change.type === \"modified\") {\n                    logger.debug('Firestore object ' + change.doc.id + ' modified');\n                    let localDoc: Bindable<T> | null = bindableArray.getDocument(change.doc.id);\n                    if (localDoc != null) {\n                        /* explode the data, but don't mess with the deep includes */\n                        explodeObject(change.doc, localDoc, false);\n                    }\n                    else {\n                        logger.debug('Firestore object ' + change.doc.id + ' not found in local collection');\n                    }\n                }\n                if (change.type === \"removed\") {\n                    logger.debug('Firestore object ' + change.doc.id + ' removed from collection');\n                    let localDoc: Bindable<T> | null = bindableArray.getDocument(change.doc.id);\n                    if (localDoc != null) {\n                        bindableArray.localOnly = true;\n                        bindableArray.remove(localDoc);\n                        bindableArray.localOnly = false;\n                    }\n                    else {\n                        /* when removing from Firestore, the snapshot is triggered, so it will try to remove it again when it's no longer there */\n                        logger.debug('Firestore object ' + change.doc.id + ' not (longer) found in local collection');\n                    }\n                }\n            }\n        });\n    });\n}\n\nfunction createFirestoreQuery(collection: firestore.Query, where: any, orderBy: any) {\n    /* convert our where and orderby arrays to real Firestore queries */\n\n    let query: firestore.Query = collection;\n\n    if (where != null && Array.isArray(where) && where.length > 0) {\n        if (Array.isArray(where[0])) {\n            for (let whereClause of where) {\n                query = query.where(whereClause[0], whereClause[1], whereClause[2]);\n            }\n        }\n        else {\n            query = query.where(where[0], where[1], where[2]);\n        }\n    }\n\n    if (orderBy != null && Array.isArray(orderBy) && orderBy.length > 0) {\n        if (Array.isArray(orderBy[0])) {\n            for (let orderByClause of orderBy) {\n                query = query.orderBy(orderByClause[0], orderByClause[1]);\n            }\n        }\n        else {\n            query = query.orderBy(orderBy[0], orderBy[1]);\n        }\n    }\n\n    return query;\n}\n\nfunction explodeObject<T>(firestoreDocument: firestore.QueryDocumentSnapshot, localObject: Bindable<T>, deepInclude: boolean) {\n    /* during update set lock on the file, so there will be no update loop */\n    localObject.lock = true;\n\n    /* enumerate using keys() and filter out protoype functions with hasOwnProperty() in stead of using \n     * getOwnPropertyNames(), because the latter also returns non-enumerables */\n    for (let key of Object.keys(localObject)) {\n        if (!localObject.hasOwnProperty(key)) continue;\n\n        let propertyData: any;\n        let property: any = (<any>localObject)[key];\n\n        /* get data from Firestore for primitive properties */\n        if (ko.isObservable(property) &&\n            !ko.isObservableArray(property) &&\n            !ko.isComputed(property)) {\n\n            propertyData = firestoreDocument.get(key);\n\n            switch (typeof propertyData) {\n                case 'undefined':\n                    break;\n                case 'string':\n                case 'number':\n                case 'boolean':\n                    property(propertyData);\n                    break;\n                case 'object':\n                    if (propertyData && typeof propertyData.toDate === 'function') { /* assume Firestore.Timestamp */\n                        property(propertyData.toDate());\n                    }\n                    break;\n            }\n        }\n\n        /* get regular arrays, or arrays not marked for deep inclusion */\n        if (ko.isObservableArray(property) && !(<any>localObject.includes)[key]) {\n            propertyData = firestoreDocument.get(key);\n\n            if (Array.isArray(propertyData)) {\n                property(propertyData);\n            }\n        }\n\n        /* get deep includes for Array properties */\n        if (deepInclude &&\n            ko.isObservableArray(property) &&\n            (<any>localObject.includes)[key] &&\n            localObject.fsBaseCollection !== undefined) {\n            let include: { class: new () => any, orderBy: [string, string] | [string, string][] } = (<any>localObject.includes)[key];\n            let collectionRef: firestore.CollectionReference = localObject.fsBaseCollection.doc(localObject.fsDocumentId).collection(key);\n            bindCollection(property, collectionRef, include.class, { twoWayBinding: localObject.twoWayBinding, orderBy: include.orderBy, logLevel: localObject.logger.logLevel }); // TODO: pass Logger in stead of logLevel\n        }\n    }\n\n    /* reset lock */\n    localObject.lock = false;\n}\n"],"sourceRoot":""}